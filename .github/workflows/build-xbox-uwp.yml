name: Build - Xbox UWP (.appx)

on:
  workflow_dispatch:
    inputs:
      version:
        description: "Version (e.g. 0.0.4)"
        required: true
        default: "0.0.4"
        type: string

jobs:
  uwpBuilder:
    name: Xbox UWP Build v${{ inputs.version }}
    runs-on: windows-2022

    steps:
      ###########################
      #         Checkout        #
      ###########################
      - name: "[Pre-install] Pull project"
        uses: actions/checkout@v4
        with:
          lfs: true
          submodules: recursive

      ###########################
      #          Cache          #
      ###########################
      - name: "[Pre-install] Restore 'library' cache"
        uses: actions/cache@v4
        with:
          path: Library
          key: YARG-Library-windows-WSAPlayer
          restore-keys: |
            YARG-Library-windows-
            YARG-Library-

      ###########################
      #     Install Blender     #
      ###########################
      - name: "[Pre-install] Cache Blender"
        id: blender-cache
        uses: actions/cache@v4
        with:
          path: C:\BlenderInstall
          key: blender-3.4.1-windows

      - name: "[Pre-install] Download Blender (3.4.1)"
        if: steps.blender-cache.outputs.cache-hit != 'true'
        run: |
          New-Item -ItemType Directory -Force -Path C:\BlenderInstall
          Invoke-WebRequest -Uri "https://download.blender.org/release/Blender3.4/blender-3.4.1-windows-x64.msi" -OutFile "C:\BlenderInstall\blender.msi"
        shell: pwsh

      - name: "[Pre-install] Install Blender (3.4.1)"
        run: |
          Start-Process msiexec.exe -ArgumentList '/i', 'C:\BlenderInstall\blender.msi', '/quiet', '/norestart', 'INSTALLDIR=C:\Blender' -Wait -NoNewWindow
        shell: pwsh

      ###########################
      #    Restore  Packages    #
      ###########################
      - name: "[Pre-install] Install .NET SDK"
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: "6.0.x"

      - name: "[Pre-install] Restore NuGet Packages"
        run: |
          dotnet tool install --global NuGetForUnity.Cli
          nugetforunity restore

      ###########################
      #     Install Unity       #
      ###########################
      - name: "[Pre-install] Download Unity Editor installer"
        run: |
          New-Item -ItemType Directory -Force -Path C:\UnityInstallers
          $changeset = "7a0645017be0"
          # Download Unity Editor
          Write-Host "Downloading Unity 2021.3.36f1 Editor..."
          Invoke-WebRequest -Uri "https://download.unity3d.com/download_unity/$changeset/Windows64EditorInstaller/UnitySetup64-2021.3.36f1.exe" -OutFile "C:\UnityInstallers\UnitySetup.exe" -UseBasicParsing
          Write-Host "Downloaded Unity Editor installer."
          # Download UWP Build Support
          Write-Host "Downloading UWP Build Support..."
          Invoke-WebRequest -Uri "https://download.unity3d.com/download_unity/$changeset/TargetSupportInstaller/UnitySetup-Universal-Windows-Platform-Support-for-Editor-2021.3.36f1.exe" -OutFile "C:\UnityInstallers\UnitySetup-UWP.exe" -UseBasicParsing
          Write-Host "Downloaded UWP Build Support installer."
        shell: pwsh
        timeout-minutes: 30

      - name: "[Pre-install] Install Unity Editor"
        run: |
          Write-Host "Installing Unity 2021.3.36f1..."
          $installDir = "C:\Program Files\Unity\2021.3.36f1"
          Start-Process -FilePath "C:\UnityInstallers\UnitySetup.exe" -ArgumentList "/S", "/D=$installDir" -Wait -NoNewWindow
          Write-Host "Unity Editor installed."
          # Install UWP support
          Write-Host "Installing UWP Build Support..."
          Start-Process -FilePath "C:\UnityInstallers\UnitySetup-UWP.exe" -ArgumentList "/S", "/D=$installDir" -Wait -NoNewWindow
          Write-Host "UWP Build Support installed."
          # Verify installation
          $unityExe = "$installDir\Editor\Unity.exe"
          if (Test-Path $unityExe) {
            Write-Host "Unity verified at: $unityExe"
          } else {
            Write-Error "Unity.exe not found after installation!"
            Get-ChildItem -Path "C:\Program Files\Unity" -Recurse -Filter "Unity.exe" -ErrorAction SilentlyContinue
            exit 1
          }
        shell: pwsh
        timeout-minutes: 30

      ###########################
      #    Activate License     #
      ###########################
      - name: "[Pre-install] Write Unity License Files"
        env:
          UNITY_LICENSE: ${{ secrets.UNITY_LICENSE }}
        run: |
          # Write the entitlement license to multiple locations Unity might check

          # Location 1: New entitlement path (user-level)
          $userLicDir = "$env:LOCALAPPDATA\Unity\licenses"
          New-Item -ItemType Directory -Force -Path $userLicDir
          Set-Content -Path "$userLicDir\UnityEntitlementLicense.xml" -Value $env:UNITY_LICENSE -Encoding UTF8
          Write-Host "Wrote license to: $userLicDir\UnityEntitlementLicense.xml"

          # Location 2: Old ULF path (system-level)
          $sysDir = "C:\ProgramData\Unity"
          New-Item -ItemType Directory -Force -Path $sysDir
          Set-Content -Path "$sysDir\Unity_lic.ulf" -Value $env:UNITY_LICENSE -Encoding UTF8
          Write-Host "Wrote license to: $sysDir\Unity_lic.ulf"

          # Location 3: CommonApplicationData Unity path
          $commonDir = [System.Environment]::GetFolderPath('CommonApplicationData')
          $commonUnity = "$commonDir\Unity"
          New-Item -ItemType Directory -Force -Path $commonUnity
          Set-Content -Path "$commonUnity\Unity_lic.ulf" -Value $env:UNITY_LICENSE -Encoding UTF8
          Write-Host "Wrote license to: $commonUnity\Unity_lic.ulf"

          # Location 4: Per-user AppData Roaming
          $roamingDir = "$env:APPDATA\Unity\licenses"
          New-Item -ItemType Directory -Force -Path $roamingDir
          Set-Content -Path "$roamingDir\UnityEntitlementLicense.xml" -Value $env:UNITY_LICENSE -Encoding UTF8
          Write-Host "Wrote license to: $roamingDir\UnityEntitlementLicense.xml"

          Write-Host "License files written to all candidate locations."
        shell: pwsh

      - name: "[Pre-install] Try CLI Activation (fallback)"
        continue-on-error: true
        run: |
          $unityExe = "C:\Program Files\Unity\2021.3.36f1\Editor\Unity.exe"
          if (Test-Path $unityExe) {
            Write-Host "Attempting Unity CLI activation with: $unityExe"
            $process = Start-Process -FilePath $unityExe -ArgumentList @(
              "-batchmode", "-nographics", "-quit",
              "-logFile", "$env:GITHUB_WORKSPACE\activation.log",
              "-createManualActivationFile"
            ) -Wait -PassThru -NoNewWindow
            Write-Host "Activation attempt exit code: $($process.ExitCode)"
            if (Test-Path "$env:GITHUB_WORKSPACE\activation.log") {
              Get-Content "$env:GITHUB_WORKSPACE\activation.log" -Tail 30
            }
            Get-ChildItem -Path $env:GITHUB_WORKSPACE -Filter "*.alf" -ErrorAction SilentlyContinue
          } else {
            Write-Host "Unity not yet installed at expected path, skipping CLI activation"
          }
        shell: pwsh

      ###########################
      #    Unity UWP Build      #
      ###########################
      - name: "[Build] Find Unity Editor"
        id: find-unity
        run: |
          # Check direct install path first
          $unityExe = "C:\Program Files\Unity\2021.3.36f1\Editor\Unity.exe"
          if (Test-Path $unityExe) {
            Write-Host "Found Unity at: $unityExe"
            echo "unity_path=$unityExe" >> $env:GITHUB_OUTPUT
            exit 0
          }
          # Fallback: search for Unity.exe
          $found = Get-ChildItem -Path "C:\Program Files\Unity" -Recurse -Filter "Unity.exe" -ErrorAction SilentlyContinue | Select-Object -First 1
          if ($found) {
            Write-Host "Found Unity at: $($found.FullName)"
            echo "unity_path=$($found.FullName)" >> $env:GITHUB_OUTPUT
            exit 0
          }
          Write-Error "Unity editor not found! Listing C:\Program Files\Unity:"
          Get-ChildItem -Path "C:\Program Files\Unity" -Recurse -Depth 3 -ErrorAction SilentlyContinue | Select-Object FullName
          exit 1
        shell: pwsh

      - name: "[Build] Build UWP Player"
        run: |
          $unityExe = "${{ steps.find-unity.outputs.unity_path }}"
          Write-Host "Building with Unity: $unityExe"
          Write-Host "Project path: $env:GITHUB_WORKSPACE"

          $process = Start-Process -FilePath $unityExe -ArgumentList @(
            "-batchmode",
            "-nographics",
            "-quit",
            "-projectPath", "$env:GITHUB_WORKSPACE",
            "-buildTarget", "WSAPlayer",
            "-executeMethod", "Editor.Build.BuildUWP.Build",
            "-logFile", "$env:GITHUB_WORKSPACE\unity-build.log"
          ) -Wait -PassThru -NoNewWindow

          if (Test-Path "$env:GITHUB_WORKSPACE\unity-build.log") {
            Write-Host "=== Unity Build Log (last 200 lines) ==="
            Get-Content "$env:GITHUB_WORKSPACE\unity-build.log" -Tail 200
          }

          if ($process.ExitCode -ne 0) {
            Write-Error "Unity build failed with exit code: $($process.ExitCode)"
            exit 1
          }
          Write-Host "Unity build completed successfully!"
        shell: pwsh
        timeout-minutes: 120

      ###########################
      #   Build Visual Studio   #
      ###########################
      - name: "[Build] Setup MSBuild"
        uses: microsoft/setup-msbuild@v2

      - name: "[Build] Install NuGet CLI"
        run: choco install nuget.commandline -y --no-progress
        shell: pwsh

      - name: "[Build] Find and build UWP solution"
        run: |
          $slnPath = Get-ChildItem -Path "build\WSAPlayer" -Filter "*.sln" -Recurse | Select-Object -First 1
          if (-not $slnPath) {
            Write-Error "No .sln file found in build\WSAPlayer"
            Get-ChildItem -Path "build" -Recurse | Select-Object FullName
            exit 1
          }
          Write-Host "Found solution: $($slnPath.FullName)"

          nuget restore $slnPath.FullName

          msbuild $slnPath.FullName `
            /p:Configuration=Master `
            /p:Platform=x64 `
            /p:AppxBundle=Never `
            /p:AppxPackageSigningEnabled=true `
            /p:PackageCertificateKeyFile="$($slnPath.DirectoryName)\YARG\WSATestCertificate.pfx" `
            /p:PackageCertificatePassword="" `
            /p:UapAppxPackageBuildMode=SideloadOnly `
            /p:AppxPackageDir="$env:GITHUB_WORKSPACE\AppxPackages\"
        shell: pwsh

      ###########################
      #    Fallback: Zip raw    #
      ###########################
      - name: "[Build] Upload Unity build log"
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: unity-build-log
          path: |
            unity-build.log
            activation.log
          if-no-files-found: ignore

      - name: "[Build] Fallback - Zip UWP build output"
        if: failure()
        run: |
          if (Test-Path "build\WSAPlayer") {
            Compress-Archive -Path "build\WSAPlayer\*" -DestinationPath "YARG_v${{ inputs.version }}-Xbox-UWP-RawBuild.zip"
          }
        shell: pwsh

      - name: "[Build] Fallback - Upload raw build"
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: YARG_v${{ inputs.version }}-Xbox-UWP-RawBuild
          path: YARG_v${{ inputs.version }}-Xbox-UWP-RawBuild.zip
          if-no-files-found: ignore

      ###########################
      #    Upload Artifacts     #
      ###########################
      - name: "[Post-build] Upload .alf (if generated)"
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: Unity-Activation-File
          path: "*.alf"
          if-no-files-found: ignore

      - name: "[Post-build] Find .appx file"
        id: find-appx
        run: |
          $appx = Get-ChildItem -Path "AppxPackages" -Filter "*.appx" -Recurse -ErrorAction SilentlyContinue | Select-Object -First 1
          if ($appx) {
            $newName = "YARG_v${{ inputs.version }}-Xbox.appx"
            Copy-Item $appx.FullName -Destination $newName
            echo "appx_path=$newName" >> $env:GITHUB_OUTPUT
            echo "found=true" >> $env:GITHUB_OUTPUT
            Write-Host "Found APPX: $($appx.FullName)"
          } else {
            echo "found=false" >> $env:GITHUB_OUTPUT
            Write-Host "No .appx found, check raw build output"
          }
        shell: pwsh

      - name: "[Post-build] Upload .appx"
        if: steps.find-appx.outputs.found == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: YARG_v${{ inputs.version }}-Xbox.appx
          path: ${{ steps.find-appx.outputs.appx_path }}

      - name: "[Post-build] Upload full AppxPackages folder"
        if: steps.find-appx.outputs.found != 'true'
        uses: actions/upload-artifact@v4
        with:
          name: YARG_v${{ inputs.version }}-Xbox-AppxPackages
          path: AppxPackages/
          if-no-files-found: ignore
